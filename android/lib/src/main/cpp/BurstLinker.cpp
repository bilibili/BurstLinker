//// Created by succlz123 on 17-9-5.//#include <jni.h>#include <string>#include <android/bitmap.h>#include <cstring>#include "../../../../../src/GifEncoder.h"#include "../../../../../src/Logger.h"#include "../../../../../src/ThreadPool.h"#ifdef __cplusplusextern "C" {#endif#define RGB565_R(p) ((((p) & 0xF800) >> 11) << 3)#define RGB565_G(p) ((((p) & 0x7E0)  >> 5)  << 2)#define RGB565_B(p) (((p)  & 0x1F)          << 3)using namespace std;using namespace blk;JNIEXPORT jlong JNICALLJava_com_bilibili_burstlinker_BurstLinker_jniInit(JNIEnv *env, jobject, jstring path, jint width,                                                  jint height, jint loopCount, jint threadCount) {    const char *pathStr = env->GetStringUTFChars(path, nullptr);    if (pathStr == nullptr) {        return 0;    }    auto *gifEncoder = new GifEncoder();    bool success = gifEncoder->init(pathStr, (uint16_t) width, (uint16_t) height,                                    (uint32_t) loopCount, (uint32_t) threadCount);    env->ReleaseStringUTFChars(path, pathStr);    if (success) {        return (jlong) gifEncoder;    } else {        delete gifEncoder;        return 0;    }}JNIEXPORT void JNICALLJava_com_bilibili_burstlinker_BurstLinker_jniDebugLog(JNIEnv *env, jobject, jlong handle,                                                      jboolean debug) {    GifEncoder *gifEncoder = (GifEncoder *) handle;    gifEncoder->debugLog = debug;}JNIEXPORT jstring JNICALLJava_com_bilibili_burstlinker_BurstLinker_jniConnect(JNIEnv *env, jobject, jlong handle,                                                     jint quantizerType,                                                     jint ditherType,                                                     jint left, jint top, jint delay,                                                     jstring rsCacheDir,                                                     jobject jBitmap) {    if (jBitmap == nullptr) {        return env->NewStringUTF("WTF!!! jBitmap == null");    }    auto *gifEncoder = (GifEncoder *) handle;    AndroidBitmapInfo androidBitmapInfo;    if (AndroidBitmap_getInfo(env, jBitmap, &androidBitmapInfo) < 0) {        return env->NewStringUTF("call AndroidBitmap_getInfo failed");    }    void *src = nullptr;    if (AndroidBitmap_lockPixels(env, jBitmap, &src) < 0) {        return env->NewStringUTF("call AndroidBitmap_lockPixels failed");    }    char *rsCacheDirStr = nullptr;    if (rsCacheDir != nullptr) {        const char *tmp = env->GetStringUTFChars(rsCacheDir, nullptr);        rsCacheDirStr = new char[strlen(tmp)];        strcpy(rsCacheDirStr, tmp);        gifEncoder->rsCacheDir = rsCacheDirStr;        env->ReleaseStringUTFChars(rsCacheDir, tmp);    }    uint16_t width = gifEncoder->screenWidth;    uint16_t height = gifEncoder->screenHeight;    uint32_t imageSize = width * height;    uint32_t *dst = new uint32_t[imageSize];    int32_t stride = 0;    if (androidBitmapInfo.format == ANDROID_BITMAP_FORMAT_RGB_565) {        stride = width * 2;        int32_t pixelsCount = stride * height;        uint16_t *tmp = new uint16_t[imageSize];        memcpy(tmp, src, static_cast<size_t>(pixelsCount));        AndroidBitmap_unlockPixels(env, jBitmap);        for (int k = 0; k < imageSize; ++k) {            uint16_t v = tmp[k];            dst[k] = RGB565_B(v) << 16 | RGB565_G(v) << 8 | RGB565_R(v);        }        delete[] tmp;    } else if (androidBitmapInfo.format == ANDROID_BITMAP_FORMAT_RGBA_8888) {        stride = width * 4;        int32_t pixelsCount = stride * height;        memcpy(dst, src, static_cast<size_t>(pixelsCount));        AndroidBitmap_unlockPixels(env, jBitmap);    } else {        return env->NewStringUTF("bitmap's format is't RGB_565 or RGBA_8888");    }    vector<uint8_t> out;    gifEncoder->addImage(dst, delay,                         static_cast<QuantizerType>(quantizerType),                         static_cast<DitherType>(ditherType),                         (uint16_t) left, (uint16_t) top, out);    if (out.size() <= 0) {        return env->NewStringUTF("gifEncoder add image out arrays is empty");    }    delete[] dst;    gifEncoder->flush(out);    return nullptr;}JNIEXPORT jstring JNICALLJava_com_bilibili_burstlinker_BurstLinker_jniConnectArray(JNIEnv *env, jobject, jlong handle,                                                          jint quantizerType,                                                          jint ditherType,                                                          jint left, jint top, jint delay,                                                          jstring rsCacheDir,                                                          jobjectArray jBitmapArray) {    auto *gifEncoder = (GifEncoder *) handle;    char *rsCacheDirStr = nullptr;    if (rsCacheDir != nullptr) {        const char *tmp = env->GetStringUTFChars(rsCacheDir, nullptr);        rsCacheDirStr = new char[strlen(tmp)];        strcpy(rsCacheDirStr, tmp);        gifEncoder->rsCacheDir = rsCacheDirStr;        env->ReleaseStringUTFChars(rsCacheDir, tmp);    }    vector<future<vector<uint8_t >>> tasks;    jsize count = env->GetArrayLength(jBitmapArray);    for (int i = 0; i < count; i++) {        jobject jBitmap = env->GetObjectArrayElement(jBitmapArray, i);        if (jBitmap == nullptr) {            return env->NewStringUTF("WTF!!! jBitmap == null");        }        AndroidBitmapInfo androidBitmapInfo;        if (AndroidBitmap_getInfo(env, jBitmap, &androidBitmapInfo) < 0) {            env->DeleteLocalRef(jBitmap);            return env->NewStringUTF("call AndroidBitmap_getInfo failed");        }        void *src = nullptr;        if (AndroidBitmap_lockPixels(env, jBitmap, &src) < 0) {            env->DeleteLocalRef(jBitmap);            return env->NewStringUTF("call AndroidBitmap_lockPixels failed");        }        uint16_t width = gifEncoder->screenWidth;        uint16_t height = gifEncoder->screenHeight;        uint32_t imageSize = width * height;        uint32_t *dst = new uint32_t[imageSize];        int32_t stride = 0;        if (androidBitmapInfo.format == ANDROID_BITMAP_FORMAT_RGB_565) {            stride = width * 2;            int32_t pixelsCount = stride * height;            uint16_t *tmp = new uint16_t[imageSize];            memcpy(tmp, src, static_cast<size_t>(pixelsCount));            AndroidBitmap_unlockPixels(env, jBitmap);            for (int k = 0; k < imageSize; ++k) {                uint16_t v = tmp[k];                dst[k] = RGB565_B(v) << 16 | RGB565_G(v) << 8 | RGB565_R(v);            }            delete[] tmp;        } else if (androidBitmapInfo.format == ANDROID_BITMAP_FORMAT_RGBA_8888) {            stride = width * 4;            int32_t pixelsCount = stride * height;            memcpy(dst, src, static_cast<size_t>(pixelsCount));            AndroidBitmap_unlockPixels(env, jBitmap);        } else {            env->DeleteLocalRef(jBitmap);            return env->NewStringUTF("bitmap's format is't RGB_565 or RGBA_8888");        }        env->DeleteLocalRef(jBitmap);        auto result = gifEncoder->threadPool->enqueue([=]() {            vector<uint8_t> out;            gifEncoder->addImage(dst, delay,                                 static_cast<QuantizerType>(quantizerType),                                 static_cast<DitherType>(ditherType),                                 (uint16_t) left, (uint16_t) top, out);            delete[] dst;            return out;        });        tasks.emplace_back(move(result));    }    for (auto &task : tasks) {        vector<uint8_t> out = task.get();        if (out.size() <= 0) {            return env->NewStringUTF("gifEncoder add image out arrays is empty");        }        gifEncoder->flush(out);    }    return nullptr;}JNIEXPORT void JNICALLJava_com_bilibili_burstlinker_BurstLinker_jniRelease(JNIEnv *env, jobject, jlong handle) {    GifEncoder *gifEncoder = (GifEncoder *) handle;    gifEncoder->finishEncoding();    delete gifEncoder;}#ifdef __cplusplus}#endif